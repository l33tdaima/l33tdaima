/**
 * Definition for binary tree with next pointer.
 */
function TreeLinkNode(val) {
    this.val = val;
    this.left = this.right = this.next = null;
}
/**
 * Decodes your encoded data to tree without link.
 *
 * @param {string} data
 * @return {TreeNode}
 */
function deserializeNoLink(data) {
    var buffer = data.split(',');
    var recDeserialize = function(buffer) {
        let elem = buffer.shift();
        if (elem === undefined || elem === '#' || elem === '') {
            return null;
        }
        let node = new TreeLinkNode(parseInt(elem));
        node.left  = recDeserialize(buffer);
        node.right = recDeserialize(buffer);
        return node;
    };
    return recDeserialize(buffer);
};
/**
 * Serialize .next val to a string following inorder traversal
 *
 * @param {TreeNode} root
 * @return {string}
 */
function serializeLink(root) {
    let buffer = [];
    let recInorder = function(root) {
        if (root == null) {
            buffer.push('#');
            return;
        }
        if (root.next == null) {
            buffer.push('#');
        } else {
            buffer.push(root.next.val);
        }
        recInorder(root.left);
        recInorder(root.right);
    };
    recInorder(root);
    return buffer.toString();
}

exports.TreeLinkNode = TreeLinkNode;
exports.deserializeNoLink = deserializeNoLink;
exports.serializeLink = serializeLink;
